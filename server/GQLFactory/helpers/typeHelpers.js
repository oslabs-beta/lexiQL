const toCamelCase = require('camelcase');
const { singular } = require('pluralize');
const { pascalCase } = require('pascal-case');
const { typeConversion, isJunctionTable } = require('./helperFunctions');

/*   Functions facilitating creation of mutation types */
const mutationsHelper = {};

mutationsHelper.create = (tableName, primaryKey, foreignKeys, columns) => {
  return `\n    ${toCamelCase(
    `add_${singular(tableName)}`
  )}(\n${mutationsHelper.mutationFields(
    primaryKey,
    foreignKeys,
    columns,
    false
  )}): ${pascalCase(singular(tableName))}!\n`;
};

mutationsHelper.delete = (tableName, primaryKey) => {
  return `\n    ${toCamelCase(
    `delete_${singular(tableName)}`
  )}(${primaryKey}: ID!): ${pascalCase(singular(tableName))}!\n`;
};

mutationsHelper.update = (tableName, primaryKey, foreignKeys, columns) => {
  return `\n    ${toCamelCase(
    `update_${singular(tableName)}`
  )}(\n${mutationsHelper.mutationFields(
    primaryKey,
    foreignKeys,
    columns,
    true
  )}): ${pascalCase(singular(tableName))}!\n`;
};

mutationsHelper.mutationFields = (
  primaryKey,
  foreignKeys,
  columns,
  primaryKeyRequired
) => {
  let mutationFields = '';
  for (const fieldName of Object.keys(columns)) {
    const { dataType, isNullable } = columns[fieldName];
    // primaryKeyRequired is used to check whether the primary key is needed for the mutation
    // create mutations do not need primary key as the ID is usually automatically generated by the database
    if (!primaryKeyRequired && fieldName === primaryKey) {
      continue;
    }
    // update mutations need the primary key to update the specific field
    // primaryKey fields are ID scalar types
    if (primaryKeyRequired && fieldName === primaryKey) {
      mutationFields += `      ${fieldName}: ID!,\n`;
      // foreignKey field types are ID scalar types
    } else if (foreignKeys && foreignKeys[fieldName]) {
      mutationFields += `      ${fieldName}: ID`;
      // if the field is not nullable and for a create mutation type, ! operator is added to the response type
      if (isNullable === 'NO' && !primaryKeyRequired) mutationFields += '!';
      mutationFields += ',\n';
    } else {
      mutationFields += `      ${fieldName}: ${
        typeConversion[dataType] ? typeConversion[dataType] : 'Int'
      }`;
      // if the field is not nullable and for a create mutation type, ! operator is added to the response type
      if (isNullable === 'NO' && !primaryKeyRequired) mutationFields += '!';
      mutationFields += ',\n';
    }
  }
  if (mutationFields !== '') mutationFields += '    ';
  return mutationFields;
};

/*   Functions facilitating creation of custom types */
const customHelper = {};
/*  Loops through SQL columns getting their name as fieldName, type, and isNullable to be returned as fields */
customHelper.getFields = (primaryKey, foreignKeys, columns) => {
  let fields = ``;
  for (const fieldName of Object.keys(columns)) {
    // check if current column is neither a foreign key or a primary key
    if ((!foreignKeys || !foreignKeys[fieldName]) && fieldName !== primaryKey) {
      const { dataType, isNullable } = columns[fieldName];
      fields += `\n  ${fieldName}: ${typeConversion[dataType]}`;
      if (isNullable === 'NO') fields += `!`;
    }
  }
  return fields;
};

customHelper.getRelationships = (tableName, sqlSchema) => {
  let relationshipFields = ``;
  const inRelationshipString = []; // used to check if field is already added
  const tableData = sqlSchema[tableName];
  const { foreignKeys, referencedBy } = tableData;
  // tableName's foreign keys : adds each foreign key as fields to custom object type
  if (foreignKeys) {
    for (const fk of Object.keys(foreignKeys)) {
      if (!inRelationshipString.includes(foreignKeys[fk].referenceTable)) {
        inRelationshipString.push(foreignKeys[fk].referenceTable);
        relationshipFields += `\n  ${toCamelCase(
          foreignKeys[fk].referenceTable
        )}: [${pascalCase(singular(foreignKeys[fk].referenceTable))}]`;
      }
    }
  }
  if (referencedBy) {
    for (const refTableName of Object.keys(referencedBy)) {
      // if the referencedby tableName is a junction table, add all of the junction table's foreign keys to
      // the current custom object type's field (excluding its own)
      if (
        isJunctionTable(
          sqlSchema[refTableName].foreignKeys,
          sqlSchema[refTableName].columns
        )
      ) {
        const { foreignKeys } = sqlSchema[refTableName];
        for (const foreignFK of Object.keys(foreignKeys)) {
          if (foreignKeys[foreignFK].referenceTable !== tableName) {
            if (
              !inRelationshipString.includes(
                foreignKeys[foreignFK].referenceTable
              )
            ) {
              inRelationshipString.push(foreignKeys[foreignFK].referenceTable);
              relationshipFields += `\n  ${toCamelCase(
                foreignKeys[foreignFK].referenceTable
              )}: [${pascalCase(
                singular(foreignKeys[foreignFK].referenceTable)
              )}]`;
            }
          }
        }
        // if referencedBy tableName is not a junction table,
        // only add the referencedBy tableName if not already added
      } else {
        if (!inRelationshipString.includes(refTableName)) {
          inRelationshipString.push(refTableName);
          relationshipFields += `\n  ${toCamelCase(
            refTableName
          )}: [${pascalCase(singular(refTableName))}]`;
        }
      }
    }
  }
  return relationshipFields;
};

module.exports = {
  mutationsHelper,
  customHelper,
};
